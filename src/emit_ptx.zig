const std = @import("std");
const lexer = @import("lexer.zig");
const parser = @import("parser.zig");
const mlir_codegen = @import("mlir_codegen.zig");

const EmitPtxError = error{
    FileNotFound,
    ParseError,
    FunctionNotFound,
    MlirError,
    InvalidArguments,
} || std.mem.Allocator.Error;

const Args = struct {
    input_file: []const u8,
    function_name: []const u8,
    sm_version: u32 = 50, // Default to SM 5.0
    verbose: bool = false,
    help: bool = false,
};

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Parse command line arguments
    const args = try parseArgs(allocator);

    if (args.help) {
        printUsage();
        return;
    }

    // Clean up duplicated strings at the end
    defer allocator.free(args.input_file);
    defer allocator.free(args.function_name);
    
    if (args.verbose) {
        std.debug.print("Emit PTX Tool\n", .{});
        std.debug.print("Input file: {s}\n", .{args.input_file});
        std.debug.print("Function: {s}\n", .{args.function_name});
        std.debug.print("SM version: {d}\n", .{args.sm_version});
    }

    // Read input file
    const source_code = std.fs.cwd().readFileAlloc(allocator, args.input_file, 1024 * 1024) catch |err| {
        switch (err) {
            error.FileNotFound => {
                std.debug.print("Error: File '{s}' not found\n", .{args.input_file});
                return EmitPtxError.FileNotFound;
            },
            else => return err,
        }
    };
    defer allocator.free(source_code);

    if (args.verbose) {
        std.debug.print("Source code loaded ({d} bytes)\n", .{source_code.len});
    }

    // Tokenize
    var lex = lexer.Lexer.init(allocator, source_code);
    const tokens = try lex.tokenize();
    defer allocator.free(tokens);

    if (args.verbose) {
        std.debug.print("Tokenized into {d} tokens\n", .{tokens.len});
    }

    // Parse
    var parse = parser.Parser.init(allocator, tokens, source_code);
    const ast = parse.parse() catch |err| {
        std.debug.print("Parse error: {}\n", .{err});
        return EmitPtxError.ParseError;
    };
    defer parser.freeAST(allocator, ast);

    if (args.verbose) {
        std.debug.print("Parsed successfully\n", .{});
    }

    // Find the specified function
    const func_decl = try findFunction(ast, args.function_name);

    if (args.verbose) {
        std.debug.print("Found function: {s}\n", .{func_decl.name});
    }

    // Check if it's a GPU function
    if (!std.mem.startsWith(u8, func_decl.name, "gpu_")) {
        std.debug.print("Warning: Function '{s}' doesn't start with 'gpu_' prefix\n", .{func_decl.name});
    }

    // Initialize MLIR codegen
    var mlir = mlir_codegen.MLIRCodeGen.init(allocator, "ptx_module", args.verbose) catch |err| {
        std.debug.print("Error initializing MLIR: {}\n", .{err});
        return EmitPtxError.MlirError;
    };
    defer mlir.deinit();

    // Generate PTX
    const ptx_code = mlir.generateGpuKernel(func_decl, args.sm_version) catch |err| {
        std.debug.print("Error generating PTX: {}\n", .{err});
        return EmitPtxError.MlirError;
    };
    defer allocator.free(ptx_code);

    // Output the PTX code
    std.debug.print("// Generated PTX for function: {s}\n", .{func_decl.name});
    std.debug.print("// Target: SM {d}\n", .{args.sm_version});
    std.debug.print("// Generated by DCC emit_ptx tool\n\n", .{});
    std.debug.print("{s}\n", .{ptx_code});
}

fn parseArgs(allocator: std.mem.Allocator) !Args {
    const args_list = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args_list);

    var result = Args{
        .input_file = "",
        .function_name = "",
    };

    if (args_list.len < 2) {
        std.debug.print("Error: Missing arguments\n\n", .{});
        printUsage();
        return EmitPtxError.InvalidArguments;
    }

    var i: usize = 1; // Skip program name
    while (i < args_list.len) {
        const arg = args_list[i];

        if (std.mem.eql(u8, arg, "--help") or std.mem.eql(u8, arg, "-h")) {
            result.help = true;
            return result;
        } else if (std.mem.eql(u8, arg, "--verbose") or std.mem.eql(u8, arg, "-v")) {
            result.verbose = true;
        } else if (std.mem.eql(u8, arg, "--sm")) {
            i += 1;
            if (i >= args_list.len) {
                std.debug.print("Error: --sm requires a value\n", .{});
                return EmitPtxError.InvalidArguments;
            }
            result.sm_version = std.fmt.parseInt(u32, args_list[i], 10) catch {
                std.debug.print("Error: Invalid SM version '{s}'\n", .{args_list[i]});
                return EmitPtxError.InvalidArguments;
            };
        } else if (std.mem.startsWith(u8, arg, "--")) {
            std.debug.print("Error: Unknown option '{s}'\n", .{arg});
            return EmitPtxError.InvalidArguments;
        } else {
            // Positional arguments
            if (result.input_file.len == 0) {
                result.input_file = try allocator.dupe(u8, arg);
            } else if (result.function_name.len == 0) {
                result.function_name = try allocator.dupe(u8, arg);
            } else {
                std.debug.print("Error: Too many positional arguments\n", .{});
                return EmitPtxError.InvalidArguments;
            }
        }
        i += 1;
    }

    if (result.input_file.len == 0) {
        std.debug.print("Error: Missing input file\n", .{});
        return EmitPtxError.InvalidArguments;
    }

    if (result.function_name.len == 0) {
        std.debug.print("Error: Missing function name\n", .{});
        return EmitPtxError.InvalidArguments;
    }

    return result;
}

fn printUsage() void {
    std.debug.print("Usage: emit_ptx [OPTIONS] <input_file> <function_name>\n\n", .{});
    std.debug.print("Generate PTX code for a specific GPU function from a toy language file\n\n", .{});
    std.debug.print("Arguments:\n", .{});
    std.debug.print("  <input_file>     Path to the toy language source file\n", .{});
    std.debug.print("  <function_name>  Name of the function to generate PTX for\n\n", .{});
    std.debug.print("Options:\n", .{});
    std.debug.print("  --sm <version>   Target SM architecture (default: 50)\n", .{});
    std.debug.print("                   Examples: 50, 60, 70, 75, 80, 86, 89\n", .{});
    std.debug.print("  -v, --verbose    Enable verbose output\n", .{});
    std.debug.print("  -h, --help       Show this help message\n\n", .{});
    std.debug.print("Examples:\n", .{});
    std.debug.print("  emit_ptx kernel.toy gpu_vector_add\n", .{});
    std.debug.print("  emit_ptx --sm 89 --verbose kernel.toy gpu_matrix_mul\n", .{});
}

fn findFunction(ast: parser.ASTNode, function_name: []const u8) !@TypeOf(@as(parser.ASTNode, undefined).function_declaration) {
    switch (ast) {
        .program => |prog| {
            for (prog.statements) |stmt| {
                switch (stmt) {
                    .function_declaration => |func| {
                        if (std.mem.eql(u8, func.name, function_name)) {
                            return func;
                        }
                    },
                    else => continue,
                }
            }
            std.debug.print("Error: Function '{s}' not found in the input file\n", .{function_name});
            return EmitPtxError.FunctionNotFound;
        },
        else => {
            std.debug.print("Error: Expected program AST node\n", .{});
            return EmitPtxError.ParseError;
        },
    }
}

test "emit_ptx basic functionality" {
    // Basic test to ensure the tool compiles
    
    // Test argument parsing with help flag
    const args = Args{
        .input_file = "test.toy",
        .function_name = "gpu_test",
        .help = true,
    };
    
    try std.testing.expect(args.help == true);
    try std.testing.expect(std.mem.eql(u8, args.input_file, "test.toy"));
    try std.testing.expect(std.mem.eql(u8, args.function_name, "gpu_test"));
} 